<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on KaenSpace</title>
    <link>https://kaendagger.github.io/categories/kotlin/</link>
    <description>Recent content in Kotlin on KaenSpace</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 11 Jul 2019 14:04:27 +0530</lastBuildDate>
    
	<atom:link href="https://kaendagger.github.io/categories/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tail Call Optimization in Kotlin</title>
      <link>https://kaendagger.github.io/posts/2019/07/tail-call-optimization-in-kotlin/</link>
      <pubDate>Thu, 11 Jul 2019 14:04:27 +0530</pubDate>
      
      <guid>https://kaendagger.github.io/posts/2019/07/tail-call-optimization-in-kotlin/</guid>
      <description>Before understanding Tail Call Optimization. Lets get a brief about “Function Call Stack” and “Recursion”
Function Call Stack When ever Java Application starts, a process starts in which our application (main thread) works. With this, Stack is maintained for the function calls. This stack contains Stack Frame which stores data of local variable to that frame.
For example, consider this sample program with three functions.
Sample Java Program
When the program starts firstly main() is called.</description>
    </item>
    
  </channel>
</rss>